! SF 2023 quick and dirty to get something for APS

program prepare_aorsa_input
  use plasma_state_mod
  use swim_global_data_mod, only : &
       & rspec, ispec, &
       & swim_error
  use aorsa2din_mod !these are from the aorsa source code and hold the
  use profile_mod   !namelist inputs for aorsa. i don't like doing it this
                    !way but i really need something that just works now
  implicit none

  !program params
  !--------------------------------------------------------------------
  real(rspec), parameter :: cubic_cm=1.e-6_rspec

  !program vars
  !--------------------------------------------------------------------
  integer :: ierr, inp_unit, out_unit, i, nrho
  logical :: lex

  !program namelist variables
  !----------------------------------------------------------------
  character(len =swim_string_length) :: cur_state_file, cur_geq_file, &
       cur_cql_file
  character(16):: arg_specs = 'MIN', dist_mode='nonmaxwell'
  integer:: arg_src_indx = 1
  integer:: arg_nphi_indx = 0 !if set to not 0 override nphi settings in input

  REAL(KIND=rspec), dimension(:), allocatable :: x_orig
  
  !program namelist block
  !----------------------------------------------------------------
  namelist /aorsa_prepare_nml/ &
           cur_state_file, cur_geq_file, cur_cql_file, &
           arg_specs, dist_mode, &
           arg_src_indx, arg_nphi_indx
  
  ! --- Begin Program Logic ---
      
  ! Read in the namelist generated by the python driver
  ! -----------------------------------------------------------------------------
  call getlun(inp_unit,ierr)
  
  OPEN (unit=inp_unit, file = 'aorsa_prepare.nml', status = 'old', &
       form = 'formatted', iostat = ierr)
  
  IF (ierr .ne. 0) THEN
     CALL SWIM_error ('open', 'prepare_aorsa_input.f90','aorsa_prepare.nml')
     WRITE (*,*) 'prepare_aorsa_input.f90: Cannot open ', 'aorsa_prepare.nml'
     call exit(1)
  END IF
  
  READ(inp_unit, nml=aorsa_prepare_nml)
  CLOSE (inp_unit)

  ! Get the plasma state
  ! -----------------------------------------------------------------------------
  call ps_get_plasma_state(ierr,trim(cur_state_file))
  if(ierr .ne. 0) stop 'cannot get plasma state to get profiles '

      
  ! Read the aorsa input file given by the ips
  ! -----------------------------------------------------------------------------
  call getlun(inp_unit,ierr)  ;  call getlun(out_unit,ierr)

  write(*,*) 'Prepare aorsa input reading aorsa_template.inp'
  open(unit=inp_unit, file='aorsa_template.in', status='old', &
       form='formatted')
  INQUIRE(inp_unit, exist=lex)
  IF (lex) THEN
     read(inp_unit, nml = aorsa2din)
     read(inp_unit, nml = state)
  ELSE
     CALL SWIM_error ('open', 'prepare_aorsa_input.f90','aorsa_template.inp')
     write(*,*) &
          'aorsa_template.inp does not exist or there was a read error'
     call exit(1)
  END IF
  close(inp_unit)

  ! Modify namelist values based on the plasma state
  ! ------------------------------------------------------------------------------
  eqdsk = cur_geq_file
  netCDF_file1 = cur_cql_file
  netCDF_file2 = cur_cql_file
  root = 'none'

  prfin = ps%power_ic(arg_src_indx)
  freqcy = ps%freq_ic(arg_src_indx)
  if (arg_nphi_indx .ne. 0) then
     nphi_number = ps%num_nphi(1)
     nphi_array = ps%nphi(arg_src_indx,:)
  endif

  ! Write numerical profiles
  n_prof_flux = 1
  iprofile = 5

  s_t0 = 0.0
  s_t1 = 0.0
  s_r_axis = 0.0
  s_z_axis = 0.0
  s_r0_mach = 0.0
  s_z0_mach = 0.0
  S_R_MIN =  0.0
  S_R_MAX =  0.0
  S_Z_MIN =  0.0
  S_Z_MAX =  0.0

  nrho = size(ps%rho)
  S_NRHO_N = nrho
  S_NRHO_T = nrho
  
  !SF kludges here are to deal with O impurity added to get
  !Zeff match in CQL3D
  S_NSPEC = ps%nspec_tha + ps%nspec_rfmin - 1
  S_NSPEC_TH = ps%nspec_tha - 1
  S_S_NAME(0:1) = ps%all_name(0:1)
  S_Q_S(0:1) = ps%m_alla(0:1)
  S_M_S(0:1) = ps%q_alla(0:1)
  S_S_NAME(2) = ps%all_name(3)
  S_Q_S(2) = ps%m_alla(3)
  S_M_S(2) = ps%q_alla(3)

  
  !set up zone centered grid
  allocate(x_orig(nrho-1))
  x_orig = 0.5_rspec * (ps%rho(1:nrho-1) + ps%rho(2:nrho))
  
  S_RHO_N_GRID(1:s_nrho_n) = ps%rho
   
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%ns(:,0), &
       S_N_S(1:s_nrho_n,0),ierr)
  call ckerr('ps_interp ns(0)',ierr)
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%ns(:,1), &
       S_N_S(1:s_nrho_n,1),ierr)
  call ckerr('ps_interp ns(1)',ierr)
  if (trim(ps%kdens_rfmin).eq.'fraction')then
     call ps_user_1dintrp_vec(ps%rho, x_orig, ps%fracmin(1)*ps%ns(:,0), &
          S_N_S(1:s_nrho_n,2),ierr)
     call ckerr('ps_interp ns(3)',ierr)

     !put modified minority density profile back in the plasma state
     call ps_user_1dintrp_vec(ps%rho,ps%rho_icrf,ps%fracmin(1)*ps%ns(:,0),  &
          ps%nmini(:,1),ierr ) 
     if(ierr .ne. 0) stop 'error interpolating new minority desnity profile onto PS grid'
  endif
  if (trim(ps%kdens_rfmin) .EQ. 'data') then
     call ps_user_1dintrp_vec(ps%rho, x_orig, ps%nmini(:,1), &
          S_N_S(1:s_nrho_n,2),ierr)
     call ckerr('ps_interp ns(3)',ierr)
  endif
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%zeff, &
       s_zeff(1:s_nrho_n),ierr)
  call ckerr('ps_interp zeff',ierr)

  S_RHO_T_GRID(1:s_nrho_t) = ps%rho
  
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%Ts(:,0), &
       S_T_S(1:s_nrho_t,0),ierr)
  call ckerr('ps_interp Ts(0)',ierr)
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%Ts(:,1), &
       S_T_S(1:s_nrho_t,1),ierr)
  call ckerr('ps_interp Ts(0)',ierr)
  !SF set minority temp to bulk temp in inputs
  call ps_user_1dintrp_vec(ps%rho, x_orig, ps%Ts(:,1), &
       S_T_S(1:s_nrho_t,2),ierr)
  call ckerr('ps_interp Ts(0)',ierr)
  
  if(trim(arg_specs) .eq. 'MIN')then
     ndisti2 = 1
  elseif(trim(arg_specs) .eq. 'MIN+')then
     ndisti1 = 1
     ndisti2 = 1
  endif

  open(unit=out_unit, file='aorsa2d.in', status='unknown', &
       form='formatted')
  write(out_unit, nml=aorsa2din)
  write(out_unit, nml=state)
  close(out_unit)
  
  contains

    SUBROUTINE getlun (ilun,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Return an unused logical unit identifier.
!
!-----------------------------------------------------------------------
!
! ****** Upon successful completion (IERR=0), the first
! ****** unused logical unit number between MINLUN and
! ****** MAXLUN, inclusive, is returned in variable ILUN.
! ****** If all units between these limits are busy,
! ****** IERR=1 is returned.
!
!-----------------------------------------------------------------------
!
      INTEGER, INTENT(OUT) :: ilun, ierr
!
!-----------------------------------------------------------------------
!
! ****** Range of valid units.
!
      INTEGER, PARAMETER :: minlun=30, maxlun=99
      LOGICAL :: busy
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Find an unused unit number.
!
      DO i=minlun,maxlun
        INQUIRE (unit=i,opened=busy)
        IF (.NOT.busy) THEN
           ilun=1
           RETURN
        END IF
      END DO
!
! ****** Fall through here if all units are busy.
!
      ierr=1
      RETURN

    END subroutine getlun
    SUBROUTINE ckerr(sbrtn,ierr)
      character*(*), intent(in) :: sbrtn
      integer, intent(in) :: ierr
      write(*,*) 'ckerr: ierr=',ierr
      IF(ierr.NE.0) then
         write(6,*) ' ?plasma_state_test: error in call: '//trim(sbrtn)
         stop
      ENDIF
    END SUBROUTINE ckerr
end program prepare_aorsa_input

  
  
  
