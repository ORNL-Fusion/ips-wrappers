#! /usr/bin/env python

"""
generic_component 10/27/2020 (Batchelor)

A simple IPS component wrapper for the case that the only thing needed is the staging of
input and state files to the work directory, execution of the physics code, and updating
of state files and archiving of the output files.  It does no processing of the input and
state files nor processing of the output files or state files which have been modified by
the physics code, except possible copying of input or output files.  In other words it is
useful if the user has in hand, or other components produce, input files readable by the
physics code, and the code output files can be used as is.  The component is generic in
that it can, without modification, wrap any physics code for use with IPS.  The
specification of all aspects of the component to be implemented is in the simulation
configuration file.  No Python programming at all is required.

It could also be used as a starting template for a much more general component.  An optional
service is provided to execute helper codes before and after the physics code run.  Thus
additional processing, such as translation between file formats can be modularly accommodated.

There are three classes of files specified in the config file: 
1) Input files which are likely used only by the physics code and are the static during  
   the workflow
2) State files which are used by multiple components and change during the course of the
   workflow.  Some state files will serve as inputs to the physics code, other state files
   will be physics code outputs that are used by other components.
3) Output files generated by the physics code but are not needed by other components

An input directory must be specified in the simulation config file which contains the input
files and any state files that the component is responsible for providing initially. The
framework maintains a state directory which contains the current set of state files and
moves state files in and out as they are produced and needed by various components.  If the
input directory contains files that are also state files then the component 'init' function 
stages these into the simulation state directory.  State file initialization can also be  
done in the simulation INIT component using the basic_init.py code.

Output files are archived to an appropriate subdirectory  of the /simulation_results/ 
directory.

The physics code may expect generic names of input files (e.g. <my_code>.in) which are not
convenient to use in the input directory or it may produce output files with inconvenient 
names. Therefore an optional service is provided to copy some files to new names   
before code execution and copy others after execution.  This is the only file processing  
done by this component.

If more work needs to be done before or after the physics code does its work, one can
specify a list of PRE_RUN_HELPER_CODES and/or POST_RUN_HELPER_CODES (full path) in the config
file which if present will be executed.  Such codes for example might interact with the
Plasma State. If input files are needed for the helper codes they must also be specified
in the component section of the config file.


Configuration parameters:

[generic_component]
# Machine dependent config info
    BIN_PATH = Path to this component script
    SCRIPT = $BIN_PATH/generic_component.py
    EXECUTABLE = Path to physics code
# Static config info
    CLASS = Class of physics component (e.g. rf)
    SUB_CLASS = Subclass of physics component (e.g. ic)
    NAME = generic_component (name of this component, i.e. implemented by generic_component.py)
    NPROC = number of processors required 
    INPUT_DIR =  Path to input directory
    INPUT_FILES = list of input files, including any state files which this component initailizes
    OUTPUT_FILES = list of output files to be archived
    STATE_FILES = list of state files used by EXECUTABLE (input or output)
    RESTART_FILES = files needed for restart
# Optional parameters
    PRE_RUN_COPY_FILES = list of files to be copied before code run
    PRE_RUN_COPY_NEW_NAMES = list of new names for files, must match PRE_RUN_COPY_FILES
    POST_RUN_COPY_FILES = list of files to be copied after code run
    POST_RUN_COPY_NEW_NAMES = list of new names for files, must match POST_RUN_COPY_FILES
    PRE_RUN_HELPER_CODES = list of codes to be executed before physics code run (full path)
    POST_RUN_HELPER_CODES = list of codes to be executed after physics code run (full path)
    LOGFILE_NAME = log file into which code standard out is directed (default = logfile.log,
                   to send output to stdout instead of logfile try = /dev/stdout)
    COMMAND_LINE_ARGS = any commmand line arguments that need to be fed to the code execution
    
"""

import utils.simple_assignment_file_edit as edit
import utils.get_IPS_config_parameters as config
import subprocess
import os
from component import Component


class generic_component (Component):
    def __init__(self, services, config):
        Component.__init__(self, services, config)
        print('Created %s' % (self.__class__))

# ------------------------------------------------------------------------------
#
# init function
#
# Moves the state files that this component is responsible for initializing into the
# state work directory.  If there are none there is nothing to do.
#
# ------------------------------------------------------------------------------

    def init(self, timeStamp=0):
        print('generic_component.init() called')

        if (self.services is None):
            message = 'Error in generic_component init (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

    # Get global configuration parameters (none for pure generic component)
 
    # Get component-specific configuration parameters. Note: Not all of these
    # are used in 'init' but if any are missing we get an exception now
    # instead of later
        BIN_PATH = config.get_component_param(self, services, 'BIN_PATH')
        RESTART_FILES = config.get_component_param(self, services, 'RESTART_FILES')
        NPROC = config.get_component_param(self, services, 'NPROC')
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')

# Nota Bene: To initialize state files initialized by this component we get state files 
# first, then input files.  That way state files in the input directory overwrite dummy
# files generated by the INIT component. It's reversed on STEP.

    # Copy state files over to working directory
        try:
            services.stage_state()
        except Exception as e:
            print('Error in call to stage_state()', e)
            services.exception('Error in call to stage_state()')
            raise

    # Get input files
        try:
            services.stage_input_files(self.INPUT_FILES)
        except Exception as e:
            print('Error in call to stageInputFiles()', e)
            self.services.exception('Error in call to stage_input_files()')
            raise

        LOGFILE_NAME = config.get_component_param(self, services, 'LOGFILE_NAME',
            optional = True)
        COMMAND_LINE_ARGS = config.get_component_param(self, services, 'COMMAND_LINE_ARGS',
            optional = True)

    # Update  state files in state work directory
        try:
            services.update_state()
        except Exception:
            message = 'Error in call to update_state()'
            print(message)
            services.exception(message)
            raise

        return

# ------------------------------------------------------------------------------
#
# RESTART function
# Gets restart files from restart directory
# Loads the global configuration parameters from the config file
#
# ------------------------------------------------------------------------------

    def restart(self, timeStamp):
        print('generic_component.restart() called')

        if (self.services is None):
            message = 'Error in generic_component restart(): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

        # Get restart files listed in config file.
        restart_root = config.get_global_param(self, services, 'RESTART_ROOT')
        restart_time = config.get_global_param(self, services, 'RESTART_TIME')

        try:
            services.get_restart_files(
                restart_root, restart_time, self.RESTART_FILES)
        except Exception:
            message = 'Error in call to get_restart_files()'
            print(message)
            self.services.exception(message)
            raise
        return 0

# ------------------------------------------------------------------------------
#
# STEP function
#
# Runs the "physics code"
#
# ------------------------------------------------------------------------------

    def step(self, timeStamp):
        print('generic_component.step() called')

        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

    # Get global configuration parameters if any (none for pure generic component)

    # Get component-specific configuration parameters.
        BIN_PATH = config.get_component_param(self, services, 'BIN_PATH')
        NPROC = config.get_component_param(self, services, 'NPROC')
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE', verbose=False)


    # Get component-specific optional configuration parameters.

        PRE_RUN_COPY_FILES = config.get_component_param(self, services,
            'PRE_RUN_COPY_FILES', optional = True, verbose = False)
        PRE_RUN_COPY_NEW_NAMES = config.get_component_param(self, services,
            'PRE_RUN_COPY_NEW_NAMES', optional = True, verbose = False)
        POST_RUN_COPY_FILES = config.get_component_param(self, services,
            'POST_RUN_COPY_FILES', optional = True, verbose = False)
        POST_RUN_COPY_NEW_NAMES = config.get_component_param(self, services,
            'POST_RUN_COPY_NEW_NAMES', optional = True, verbose = False)

        PRE_RUN_HELPER_CODES = config.get_component_param(self, services,
            'PRE_RUN_HELPER_CODES', optional = True, verbose = False)
        POST_RUN_HELPER_CODES = config.get_component_param(self, services,
            'POST_RUN_HELPER_CODES', optional = True, verbose = False)

        LOGFILE_NAME = config.get_component_param(self, services, 'LOGFILE_NAME',
            optional = True, verbose = False)
        COMMAND_LINE_ARGS = config.get_component_param(self, services, 'COMMAND_LINE_ARGS',
            optional = True, verbose = False)

# Nota Bene: On STEP we get input files first then state.  That way any initial state files
#  in the input directory are overwritten by the current files in state.  It's reversed 
#  on INIT.

    # Get input files
        try:
            services.stage_input_files(self.INPUT_FILES)
        except Exception:
            print('Error in call to stageInputFiles()')
            self.services.exception('Error in call to stageInputFiles()')
            raise

    # Copy state files over to working directory
        try:
            services.stage_state()
        except Exception as e:
            print('Error in call to stage_state()', e)
            services.exception('Error in call to stage_state()')
            raise

    # Copy files if there are files to be renamed before physics code run

        COPY_FILES = PRE_RUN_COPY_FILES
        COPIED_FILES_NEW_NAMES = PRE_RUN_COPY_NEW_NAMES
        # Check if there are files to be renamed
        if COPY_FILES is not None and len(COPY_FILES) > 0:
            COPY_FILES = COPY_FILES.split(' ')
            COPIED_FILES_NEW_NAMES = COPIED_FILES_NEW_NAMES.split(' ')
            # Verify that list lengths are the same
            if len(COPY_FILES) != len(COPIED_FILES_NEW_NAMES):
                message = ('Error in generic_component init: COPY_FILES and '
                    'COPIED_FILES_NEW_NAMES lists are different lengths')
                print(message)
                self.services.error(message)
                raise Exception(message)
            # Copy the files
            for i in range(len(COPY_FILES)):
                try:
                    os.system('cp ' + COPY_FILES[i] + ' ' + COPIED_FILES_NEW_NAMES[i])
                except OSError as xxx_todo_changeme:
                    (errno, strerror) = xxx_todo_changeme.args
                    print('Error copying file %s to %s' % (COPY_FILES[i],
                     COPIED_FILES_NEW_NAMES[i]), strerror)
                    services.error(COPY_FILES[i] + '-> ' + COPIED_FILES_NEW_NAMES[i])
                    raise Exception('Error copying COPY_FILES -> COPIED_FILES_NEW_NAMES')

   # Execute PRE_RUN_HELPER_CODES if any
        # Check if there are codes to be run
        if PRE_RUN_HELPER_CODES is not None and len(PRE_RUN_HELPER_CODES) > 0:
            HELPER_CODES = PRE_RUN_HELPER_CODES.split(' ')
            for code in HELPER_CODES:
                cmd = [code]
                print('Executing ', cmd)
                services.send_portal_event(event_type='COMPONENT_EVENT',
                                           event_comment=cmd)
                retcode = subprocess.call(cmd)
                if (retcode != 0):
                    logMsg = 'Error executing '.join(map(str, cmd))
                    self.services.error(logMsg)
                    raise Exception(logMsg)


    # Run physics code
        if LOGFILE_NAME is not None and len(LOGFILE_NAME) > 0:
            LOGFILE = LOGFILE_NAME
        else:
            LOGFILE = 'logfile.log'


        cmd = EXECUTABLE
        if COMMAND_LINE_ARGS is not None and len(COMMAND_LINE_ARGS) > 0:
            cmd = EXECUTABLE + COMMAND_LINE_ARGS
       
        print('\nExecuting = ', cmd)
        services.send_portal_event(event_type='COMPONENT_EVENT',event_comment=cmd)
        cwd = services.get_working_dir()
        task_id = services.launch_task(self.NPROC, cwd, cmd, logfile=LOGFILE)
        retcode = services.wait_task(task_id)
        if (retcode != 0):
            message = 'Error executing ', cmd
            print(message)
            self.services.error(message)
            raise Exception(message)
        print(cmd, ' finished \n')


   # Execute POST_RUN_HELPER_CODES if any
        # Check if there are codes to be run
        if POST_RUN_HELPER_CODES is not None and len(POST_RUN_HELPER_CODES) > 0:
            HELPER_CODES = POST_RUN_HELPER_CODES.split(' ')
            for code in HELPER_CODES:
                cmd = [code]
                print('Executing ', cmd)
                services.send_portal_event(event_type='COMPONENT_EVENT',
                                           event_comment=cmd)
                retcode = subprocess.call(cmd)
                if (retcode != 0):
                    logMsg = 'Error executing '.join(map(str, cmd))
                    self.services.error(logMsg)
                    raise Exception(logMsg)

    # Copy files if there are files to be renamed after physics code run

        COPY_FILES = POST_RUN_COPY_FILES
        COPIED_FILES_NEW_NAMES = POST_RUN_COPY_NEW_NAMES
        # Check if there are files to be renamed
        if COPY_FILES is not None and len(COPY_FILES) > 0:
            COPY_FILES = COPY_FILES.split(' ')
        if COPIED_FILES_NEW_NAMES is not None and len(COPIED_FILES_NEW_NAMES) > 0:
            COPIED_FILES_NEW_NAMES = COPIED_FILES_NEW_NAMES.split(' ')
            # Verify that list lengths are the same
            if len(COPY_FILES) != len(COPIED_FILES_NEW_NAMES):
                message = ('Error in generic_component init: COPY_FILES and '
                    'COPIED_FILES_NEW_NAMES lists are different lengths')
                print(message)
                self.services.error(message)
                raise Exception(message)
            # Copy the files
            for i in range(len(COPY_FILES)):
                try:
                    os.system('cp ' + COPY_FILES[i] + ' ' + COPIED_FILES_NEW_NAMES[i])
                except OSError as xxx_todo_changeme:
                    (errno, strerror) = xxx_todo_changeme.args
                    print('Error copying file %s to %s' % (COPY_FILES[i],
                     COPIED_FILES_NEW_NAMES[i]), strerror)
                    services.error(COPY_FILES[i] + '-> ' + COPIED_FILES_NEW_NAMES[i])
                    raise Exception('Error copying COPY_FILES -> COPIED_FILES_NEW_NAMES')

# Update state files in state work directory
        try:
            services.update_state()
        except Exception:
            message = 'Error in call to update_state()'
            print(message)
            services.error(message)
            raise

# "Archive" output files in history directory
        try:
            services.stage_output_files(timeStamp, self.OUTPUT_FILES)
        except Exception:
            message = 'Error in call to stage_output_files()'
            print(message)
            services.error(message)
            raise

        return 0

# ------------------------------------------------------------------------------
#
# checkpoint function
# Saves  state files to restart directory
#
# ------------------------------------------------------------------------------

    def checkpoint(self, timestamp=0.0):
        print('generic_component.checkpoint() called')
        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')
        if (self.services is None):
            message = 'Error in generic_component init (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        services.save_restart_files(timestamp, self.RESTART_FILES)
        return 0

# ------------------------------------------------------------------------------
#
# finalize function
#
# Does nothing
# ------------------------------------------------------------------------------

    def finalize(self, timestamp=0.0):
        print('generic_component finalize() called')
        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')
